<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bubble Level: nucleo-l432kc_9dof-imu-click/Core/Src/mpu9dof.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Bubble Level
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_c60c5f541fe417ea2feca524824005cb.html">nucleo-l432kc_9dof-imu-click</a></li><li class="navelem"><a class="el" href="dir_7da1bb9ed278c7805e71feff8d6f14f7.html">Core</a></li><li class="navelem"><a class="el" href="dir_122c80c39f15cc8cad61c2a1999acce5.html">Src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">mpu9dof.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="mpu9dof_8h_source.html">mpu9dof.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_raw_data.html">RawData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_offset_values.html">OffsetValues</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing offset values for gyroscope and accelerometer. The <a class="el" href="struct_offset_values.html" title="Structure representing offset values for gyroscope and accelerometer. The OffsetValues struct is used...">OffsetValues</a> struct is used to store the offset values for the gyro and accelerometer. It contains two arrays, gyro_offset and acc_offset, which hold the offset values for the gyro and accelerometer. Each array has three elements of type int16_t, representing the offset values along the x, y, and z axes. These offset values are typically determined during a calibration process and are used to compensate for any biases or errors in the sensor readings. By applying the offset values, more accurate and reliable measurements can be obtained.  <a href="struct_offset_values.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_calibrated_data.html">CalibratedData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to store the calibrated data for the accelerometer and gyroscope It contains two arrays, acc_calib and gyro_calib, which hold the calibrated values for the accelerometer and gyroscope, respectively. Each array has three elements of type int16_t, representing the calibrated values along the x, y, and z axes. These calibrated values have been adjusted to remove any biases or errors present in the raw sensor readings. By using the calibrated data, more accurate and reliable measurements can be obtained from the accelerometer and gyroscope.  <a href="struct_calibrated_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_processed_data.html">ProcessedData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing processed data including bubble level and shake detection. The <a class="el" href="struct_processed_data.html" title="Structure representing processed data including bubble level and shake detection. The ProcessedData s...">ProcessedData</a> structure is used to store the processed data, which includes the bubble level readings and shake detection result. The roll and pitch variables are of type int16_t and represent the angles of the bubble level along the horizontal (roll) and vertical (pitch) axes. These values indicate the orientation or tilt of the object being measured. The shake variable is of type uint8_t and represents the shake detection result. It is used to indicate whether a shake or vibration event has been detected. A value of 1 indicates a shake or vibration is detected, while a value of 0 indicates no shake or vibration is detected.  <a href="struct_processed_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1c1a027426b35b6c5326bff15581e0b6"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_raw_data.html">RawData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a1c1a027426b35b6c5326bff15581e0b6">RawData</a></td></tr>
<tr class="separator:a1c1a027426b35b6c5326bff15581e0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17b9a90befa6219ed31247a27bd3ec2"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_offset_values.html">OffsetValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#aa17b9a90befa6219ed31247a27bd3ec2">OffsetValues</a></td></tr>
<tr class="memdesc:aa17b9a90befa6219ed31247a27bd3ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing offset values for gyroscope and accelerometer. The <a class="el" href="struct_offset_values.html" title="Structure representing offset values for gyroscope and accelerometer. The OffsetValues struct is used...">OffsetValues</a> struct is used to store the offset values for the gyro and accelerometer. It contains two arrays, gyro_offset and acc_offset, which hold the offset values for the gyro and accelerometer. Each array has three elements of type int16_t, representing the offset values along the x, y, and z axes. These offset values are typically determined during a calibration process and are used to compensate for any biases or errors in the sensor readings. By applying the offset values, more accurate and reliable measurements can be obtained.  <a href="mpu9dof_8c.html#aa17b9a90befa6219ed31247a27bd3ec2">More...</a><br /></td></tr>
<tr class="separator:aa17b9a90befa6219ed31247a27bd3ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb89d28854cbbf9e7f47c5aafb2cbad"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_calibrated_data.html">CalibratedData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a8eb89d28854cbbf9e7f47c5aafb2cbad">CalibratedData</a></td></tr>
<tr class="memdesc:a8eb89d28854cbbf9e7f47c5aafb2cbad"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to store the calibrated data for the accelerometer and gyroscope It contains two arrays, acc_calib and gyro_calib, which hold the calibrated values for the accelerometer and gyroscope, respectively. Each array has three elements of type int16_t, representing the calibrated values along the x, y, and z axes. These calibrated values have been adjusted to remove any biases or errors present in the raw sensor readings. By using the calibrated data, more accurate and reliable measurements can be obtained from the accelerometer and gyroscope.  <a href="mpu9dof_8c.html#a8eb89d28854cbbf9e7f47c5aafb2cbad">More...</a><br /></td></tr>
<tr class="separator:a8eb89d28854cbbf9e7f47c5aafb2cbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0f68ad9a4803efbb1f05c96551872b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_processed_data.html">ProcessedData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a2f0f68ad9a4803efbb1f05c96551872b">ProcessedData</a></td></tr>
<tr class="memdesc:a2f0f68ad9a4803efbb1f05c96551872b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure representing processed data including bubble level and shake detection. The <a class="el" href="struct_processed_data.html" title="Structure representing processed data including bubble level and shake detection. The ProcessedData s...">ProcessedData</a> structure is used to store the processed data, which includes the bubble level readings and shake detection result. The roll and pitch variables are of type int16_t and represent the angles of the bubble level along the horizontal (roll) and vertical (pitch) axes. These values indicate the orientation or tilt of the object being measured. The shake variable is of type uint8_t and represents the shake detection result. It is used to indicate whether a shake or vibration event has been detected. A value of 1 indicates a shake or vibration is detected, while a value of 0 indicates no shake or vibration is detected.  <a href="mpu9dof_8c.html#a2f0f68ad9a4803efbb1f05c96551872b">More...</a><br /></td></tr>
<tr class="separator:a2f0f68ad9a4803efbb1f05c96551872b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a949f4308c28a7a773584c8e6c281e3cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a949f4308c28a7a773584c8e6c281e3cb">mpu9dof_default_cfg</a> ()</td></tr>
<tr class="memdesc:a949f4308c28a7a773584c8e6c281e3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">:  <a href="mpu9dof_8c.html#a949f4308c28a7a773584c8e6c281e3cb">More...</a><br /></td></tr>
<tr class="separator:a949f4308c28a7a773584c8e6c281e3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc02bdc34e18dabb24af73d49310a0df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#abc02bdc34e18dabb24af73d49310a0df">mpu9dof_read</a> (const uint8_t *sensor)</td></tr>
<tr class="memdesc:abc02bdc34e18dabb24af73d49310a0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read sensor data from MPU9DOF module.  <a href="mpu9dof_8c.html#abc02bdc34e18dabb24af73d49310a0df">More...</a><br /></td></tr>
<tr class="separator:abc02bdc34e18dabb24af73d49310a0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d279570f140f310e675e91b1d73b1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#af7d279570f140f310e675e91b1d73b1a">mpu9dof_calibrate_module</a> ()</td></tr>
<tr class="memdesc:af7d279570f140f310e675e91b1d73b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibrates the 9DOF MPU module by calculating the value of the sample data. This function performs calibration for the 9DOF MPU module. The calibration process is performed by reading gyro data using the <a class="el" href="mpu9dof_8c.html#abc02bdc34e18dabb24af73d49310a0df" title="Read sensor data from MPU9DOF module.">mpu9dof_read()</a> function with the sensor type set to GYRO. The sample data is accumulated in the gyro_sum array. After collecting the required number of samples defined by CALIBRATION_SAMPLES, the mean value is calculated for each gyro axis. The gyro offset values are stored in the offsetValues.gyro_offset array, and the calibrated gyro data is stored in the calibratedData.gyro_calib array. Additionally, a normal 1G offset of the accelerometer in the Z-axis is accounted for by subtracting 16384 from the offsetValues.acc_offset[2] value. The calibrated accelerometer data is stored in the calibratedData.acc_calib[2] variable.  <a href="mpu9dof_8c.html#af7d279570f140f310e675e91b1d73b1a">More...</a><br /></td></tr>
<tr class="separator:af7d279570f140f310e675e91b1d73b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e71fb6014f5c2527ce9ba6928cec83"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a62e71fb6014f5c2527ce9ba6928cec83">mpu9dof_process</a> ()</td></tr>
<tr class="memdesc:a62e71fb6014f5c2527ce9ba6928cec83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process sensor data and calculate roll, pitch, and shake detection. This function processes the sensor data and performs calculations to determine the roll, pitch, and shake detection values. It takes the raw gyro and accelerometer data from rawData and applies necessary conversions to obtain the values in appropriate units. The function converts the raw gyro values to degrees per second by subtracting the gyro offset values and dividing by 131.0. Similarly, the raw accelerometer values are converted to G's by dividing them by 4096.0. The roll and pitch angles are calculated from the accelerometer data using the atan2f function and then converted to degrees by multiplying with the RAD_TO_DEG constant. The complementary filter is applied to combine the gyro and accelerometer data for the roll and pitch angles. The filtered roll and pitch values are updated in processedData using the COMPLEMENTARY_RATIO and DELTA_TIME constants. The shake detection is performed by calculating the magnitude of the accelerometer readings and comparing it to the SHAKE_THRESHOLD. If the magnitude exceeds the threshold, shake is considered to be detected, and the processedData.shake value is set to 0; otherwise, it is set to 1. The function returns a pointer to the processedData structure containing the calculated roll, pitch, and shake values.  <a href="mpu9dof_8c.html#a62e71fb6014f5c2527ce9ba6928cec83">More...</a><br /></td></tr>
<tr class="separator:a62e71fb6014f5c2527ce9ba6928cec83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5433079579490b97f6094c3659af0089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a5433079579490b97f6094c3659af0089">mpu9dof_log_data</a> (const uint8_t *data)</td></tr>
<tr class="memdesc:a5433079579490b97f6094c3659af0089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log data based on the specified type.  <a href="mpu9dof_8c.html#a5433079579490b97f6094c3659af0089">More...</a><br /></td></tr>
<tr class="separator:a5433079579490b97f6094c3659af0089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19362190b7708f09cf198ac33319d513"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a19362190b7708f09cf198ac33319d513">mpu9dof_generic_write</a> (const uint8_t *reg, const uint8_t *data_buf, const uint8_t *len)</td></tr>
<tr class="memdesc:a19362190b7708f09cf198ac33319d513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic write function for MPU9DOF module.  <a href="mpu9dof_8c.html#a19362190b7708f09cf198ac33319d513">More...</a><br /></td></tr>
<tr class="separator:a19362190b7708f09cf198ac33319d513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01269a22d6a6e761803b82be318f568e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a01269a22d6a6e761803b82be318f568e">mpu9dof_generic_read</a> (const uint8_t *reg, uint8_t *data_buf, const uint8_t *len)</td></tr>
<tr class="memdesc:a01269a22d6a6e761803b82be318f568e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic read function for MPU9DOF module. This function is used to read data from the MPU9DOF module. It accepts a register address specified by the reg parameter, a data buffer specified by the data_buf parameter, and the length of the data buffer specified by the len parameter. The function begins by acquiring a critical section to ensure exclusive access to shared resources. It then calls the HAL_I2C_Mem_Read function to read data from the MPU9DOF module. The function specifies the I2C interface (hi2c1), the I2C device address obtained by left-shifting MPU9DOF_XLG_I2C_ADDR_1 by 1, the register address (*reg), the size of the register address (I2C_MEMADD_SIZE_8BIT), the data buffer to store the read data (data_buf), the length of the data to be read (*len), and the maximum delay for the operation (HAL_MAX_DELAY). Finally, the function releases the critical section and returns.  <a href="mpu9dof_8c.html#a01269a22d6a6e761803b82be318f568e">More...</a><br /></td></tr>
<tr class="separator:a01269a22d6a6e761803b82be318f568e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af7b2c26e44dadaaa798a5c3d82914ba7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___i2_c__handle___structure__definition.html#ga31b88eb31a4622a50e34f02a1c3d516b">I2C_HandleTypeDef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#af7b2c26e44dadaaa798a5c3d82914ba7">hi2c1</a></td></tr>
<tr class="separator:af7b2c26e44dadaaa798a5c3d82914ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace92afad010308cb88a74c110408833a"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#ace92afad010308cb88a74c110408833a">MPU9DOF_XLG_I2C_ADDR_1</a> = 0x69</td></tr>
<tr class="separator:ace92afad010308cb88a74c110408833a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b750fec54c6406d16a2c0238dcf56af"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a4b750fec54c6406d16a2c0238dcf56af">MPU9DOF_BIT_H_RESET</a> = 0x80</td></tr>
<tr class="separator:a4b750fec54c6406d16a2c0238dcf56af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e0846dacaf6675bc6466a4d70ca723"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a49e0846dacaf6675bc6466a4d70ca723">MPU9DOF_DEFAULT</a> = 0x00</td></tr>
<tr class="separator:a49e0846dacaf6675bc6466a4d70ca723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aade376745f1e7a469a10b26ebd551b"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a3aade376745f1e7a469a10b26ebd551b">MPU9DOF_BITS_DLPF_CFG_42HZ</a> = 0x03</td></tr>
<tr class="separator:a3aade376745f1e7a469a10b26ebd551b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc769bbe277a45f1c29e1e7a18ccb2d"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a4bc769bbe277a45f1c29e1e7a18ccb2d">MPU9DOF_BIT_FIFO_DIS</a> = 0x00</td></tr>
<tr class="separator:a4bc769bbe277a45f1c29e1e7a18ccb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5912f4f5b0d9e8556f28b98925153ac1"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a5912f4f5b0d9e8556f28b98925153ac1">MPU9DOF_BIT_INT_PIN_CFG</a> = 0x02</td></tr>
<tr class="separator:a5912f4f5b0d9e8556f28b98925153ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa373db1d9e00d5d106cca10baa96ea84"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#aa373db1d9e00d5d106cca10baa96ea84">MPU9DOF_SMPLRT_DIV</a> = 0x19</td></tr>
<tr class="separator:aa373db1d9e00d5d106cca10baa96ea84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b2f8caba4e8478afe874b05b753580"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#ad6b2f8caba4e8478afe874b05b753580">MPU9DOF_CONFIG</a> = 0x1A</td></tr>
<tr class="separator:ad6b2f8caba4e8478afe874b05b753580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68dd2a28e55296623b64ccf23981bae"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#aa68dd2a28e55296623b64ccf23981bae">MPU9DOF_GYRO_CONFIG</a> = 0x1B</td></tr>
<tr class="separator:aa68dd2a28e55296623b64ccf23981bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b219909a48ba3d698653a9848002115"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a7b219909a48ba3d698653a9848002115">MPU9DOF_ACCEL_CONFIG</a> = 0x1C</td></tr>
<tr class="separator:a7b219909a48ba3d698653a9848002115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c83376e098321319e0c103239aeae3"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#ab0c83376e098321319e0c103239aeae3">MPU9DOF_FIFO_EN</a> = 0x23</td></tr>
<tr class="separator:ab0c83376e098321319e0c103239aeae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c9eeb5dfe6896666902cb99a13d527"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a18c9eeb5dfe6896666902cb99a13d527">MPU9DOF_INT_PIN_CFG</a> = 0x37</td></tr>
<tr class="separator:a18c9eeb5dfe6896666902cb99a13d527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0196791086d75eab99490549ff150ad6"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a0196791086d75eab99490549ff150ad6">MPU9DOF_INT_ENABLE</a> = 0x38</td></tr>
<tr class="separator:a0196791086d75eab99490549ff150ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbcc92b4f26c722f378422726a6f0d72"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#afbcc92b4f26c722f378422726a6f0d72">MPU9DOF_USER_CTRL</a> = 0x6A</td></tr>
<tr class="separator:afbcc92b4f26c722f378422726a6f0d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90aa4fe3af751fa4f17406a9c98f67e2"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a90aa4fe3af751fa4f17406a9c98f67e2">MPU9DOF_PWR_MGMT_1</a> = 0x6B</td></tr>
<tr class="separator:a90aa4fe3af751fa4f17406a9c98f67e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc1c865f06de7a6fab00a6084fb86fe"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#aedc1c865f06de7a6fab00a6084fb86fe">MPU9DOF_PWR_MGMT_2</a> = 0x6C</td></tr>
<tr class="separator:aedc1c865f06de7a6fab00a6084fb86fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd230107adbbce5cf82791ef10e9dd23"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#abd230107adbbce5cf82791ef10e9dd23">MPU9DOF_BITS_FS_250DPS</a> = 0x00</td></tr>
<tr class="memdesc:abd230107adbbce5cf82791ef10e9dd23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sensitivity settings for accelerometer and gyroscope. These constants define the sensitivity settings for the accelerometer and gyroscope of the MPU-9DOF sensor. MPU9DOF_BITS_FS_250DPS: Sensitivity setting for the gyroscope at 250 degrees per second. MPU9DOF_BITS_AFSL_SEL_8G: Sensitivity setting for the accelerometer at 8g.  <a href="mpu9dof_8c.html#abd230107adbbce5cf82791ef10e9dd23">More...</a><br /></td></tr>
<tr class="separator:abd230107adbbce5cf82791ef10e9dd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f45263b150c5a7926b58ae1fefd3806"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a9f45263b150c5a7926b58ae1fefd3806">MPU9DOF_BITS_AFSL_SEL_8G</a> = 0x10</td></tr>
<tr class="separator:a9f45263b150c5a7926b58ae1fefd3806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa003a2decca0e11c619289f80f9d33ff"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#aa003a2decca0e11c619289f80f9d33ff">MPU9DOF_GYRO_XOUT_H</a> = 0x43</td></tr>
<tr class="memdesc:aa003a2decca0e11c619289f80f9d33ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">High registers of the gyroscope and accelerometer. These constants define the addresses of the high registers of the gyroscope and accelerometer in the MPU-9DOF sensor. MPU9DOF_GYRO_XOUT_H: Address of the high register for the X-axis gyroscope output. MPU9DOF_GYRO_YOUT_H: Address of the high register for the Y-axis gyroscope output. MPU9DOF_GYRO_ZOUT_H: Address of the high register for the Z-axis gyroscope output. MPU9DOF_ACCEL_XOUT_H: Address of the high register for the X-axis accelerometer output. MPU9DOF_ACCEL_YOUT_H: Address of the high register for the Y-axis accelerometer output. MPU9DOF_ACCEL_ZOUT_H: Address of the high register for the Z-axis accelerometer output.  <a href="mpu9dof_8c.html#aa003a2decca0e11c619289f80f9d33ff">More...</a><br /></td></tr>
<tr class="separator:aa003a2decca0e11c619289f80f9d33ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f9f5d494a3ccc3c87c8fb88ae287dd"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#aa0f9f5d494a3ccc3c87c8fb88ae287dd">MPU9DOF_GYRO_YOUT_H</a> = 0x45</td></tr>
<tr class="separator:aa0f9f5d494a3ccc3c87c8fb88ae287dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05da3d1b8555e6647aa4bcb108cd47f1"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a05da3d1b8555e6647aa4bcb108cd47f1">MPU9DOF_GYRO_ZOUT_H</a> = 0x47</td></tr>
<tr class="separator:a05da3d1b8555e6647aa4bcb108cd47f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee7c56be6f5ccd8c9fc46bd8f64fe1d"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a5ee7c56be6f5ccd8c9fc46bd8f64fe1d">MPU9DOF_ACCEL_XOUT_H</a> = 0x3B</td></tr>
<tr class="separator:a5ee7c56be6f5ccd8c9fc46bd8f64fe1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ab19293e1923b48e195a2cba1bdb0e"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#af3ab19293e1923b48e195a2cba1bdb0e">MPU9DOF_ACCEL_YOUT_H</a> = 0x3D</td></tr>
<tr class="separator:af3ab19293e1923b48e195a2cba1bdb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323047f22c2674ae3ea96f2c4f8d331d"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a323047f22c2674ae3ea96f2c4f8d331d">MPU9DOF_ACCEL_ZOUT_H</a> = 0x3F</td></tr>
<tr class="separator:a323047f22c2674ae3ea96f2c4f8d331d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e92e8253a6240e36fc8ed496aec2a03"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a3e92e8253a6240e36fc8ed496aec2a03">SHAKE_THRESHOLD</a> = 2.5</td></tr>
<tr class="memdesc:a3e92e8253a6240e36fc8ed496aec2a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants for motion sensing. These constants define various parameters used in motion sensing calculations. SHAKE_THRESHOLD: Threshold for detecting shaking motion, specified in units of G's (acceleration due to gravity). DELTA_TIME: Time interval between sensor readings, expressed as the reciprocal of the sampling rate (30 times per second). RAD_TO_DEG: Conversion constant for converting radians to degrees. COMPLEMENTARY_RATIO: Complementary filter ratio used in sensor fusion algorithms, obtained from external knowledge sources.  <a href="mpu9dof_8c.html#a3e92e8253a6240e36fc8ed496aec2a03">More...</a><br /></td></tr>
<tr class="separator:a3e92e8253a6240e36fc8ed496aec2a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41d7e66c90529c1f3d8e8be9df8ed95"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#ad41d7e66c90529c1f3d8e8be9df8ed95">DELTA_TIME</a> = 1.0/30.0</td></tr>
<tr class="separator:ad41d7e66c90529c1f3d8e8be9df8ed95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374e8373687339ac309e4f02b305fb0f"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a374e8373687339ac309e4f02b305fb0f">RAD_TO_DEG</a> = 57.2957795131</td></tr>
<tr class="separator:a374e8373687339ac309e4f02b305fb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13aa37077c3b71dfcadf38e1bc7bfe4"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#aa13aa37077c3b71dfcadf38e1bc7bfe4">COMPLEMENTARY_RATIO</a> = 0.98</td></tr>
<tr class="separator:aa13aa37077c3b71dfcadf38e1bc7bfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1159e4f53de21839e7731629ab36c2d6"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a1159e4f53de21839e7731629ab36c2d6">CALIBRATION_SAMPLES</a> = 50</td></tr>
<tr class="memdesc:a1159e4f53de21839e7731629ab36c2d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the number of example values to be recorded for calibration. This constant variable determines the number of example values that should be recorded for the calibration process. It is of type uint8_t, which represents an unsigned 8-bit integer. The calibration process is used to establish reference values or parameters for calculations.  <a href="mpu9dof_8c.html#a1159e4f53de21839e7731629ab36c2d6">More...</a><br /></td></tr>
<tr class="separator:a1159e4f53de21839e7731629ab36c2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a58ed8cae092f222d56fb8b32a99080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_raw_data.html">RawData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a6a58ed8cae092f222d56fb8b32a99080">rawData</a></td></tr>
<tr class="separator:a6a58ed8cae092f222d56fb8b32a99080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cb247ad8a7279a9d4e6b505496bc4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_processed_data.html">ProcessedData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a10cb247ad8a7279a9d4e6b505496bc4b">processedData</a></td></tr>
<tr class="separator:a10cb247ad8a7279a9d4e6b505496bc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f219b8466fd2ccc99d8f7546f9e739"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_offset_values.html">OffsetValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a98f219b8466fd2ccc99d8f7546f9e739">offsetValues</a></td></tr>
<tr class="separator:a98f219b8466fd2ccc99d8f7546f9e739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7930346cc386f4dd9d626edcc6bdc716"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_calibrated_data.html">CalibratedData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpu9dof_8c.html#a7930346cc386f4dd9d626edcc6bdc716">calibratedData</a></td></tr>
<tr class="separator:a7930346cc386f4dd9d626edcc6bdc716"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a8eb89d28854cbbf9e7f47c5aafb2cbad" name="a8eb89d28854cbbf9e7f47c5aafb2cbad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb89d28854cbbf9e7f47c5aafb2cbad">&#9670;&#160;</a></span>CalibratedData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_calibrated_data.html">CalibratedData</a> <a class="el" href="struct_calibrated_data.html">CalibratedData</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>used to store the calibrated data for the accelerometer and gyroscope It contains two arrays, acc_calib and gyro_calib, which hold the calibrated values for the accelerometer and gyroscope, respectively. Each array has three elements of type int16_t, representing the calibrated values along the x, y, and z axes. These calibrated values have been adjusted to remove any biases or errors present in the raw sensor readings. By using the calibrated data, more accurate and reliable measurements can be obtained from the accelerometer and gyroscope. </p>
<dl class="section see"><dt>See also</dt><dd>acc_calib </dd>
<dd>
gyro_calib </dd></dl>

</div>
</div>
<a id="aa17b9a90befa6219ed31247a27bd3ec2" name="aa17b9a90befa6219ed31247a27bd3ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17b9a90befa6219ed31247a27bd3ec2">&#9670;&#160;</a></span>OffsetValues</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_offset_values.html">OffsetValues</a> <a class="el" href="struct_offset_values.html">OffsetValues</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure representing offset values for gyroscope and accelerometer. The <a class="el" href="struct_offset_values.html" title="Structure representing offset values for gyroscope and accelerometer. The OffsetValues struct is used...">OffsetValues</a> struct is used to store the offset values for the gyro and accelerometer. It contains two arrays, gyro_offset and acc_offset, which hold the offset values for the gyro and accelerometer. Each array has three elements of type int16_t, representing the offset values along the x, y, and z axes. These offset values are typically determined during a calibration process and are used to compensate for any biases or errors in the sensor readings. By applying the offset values, more accurate and reliable measurements can be obtained. </p>
<dl class="section see"><dt>See also</dt><dd>gyro_offset </dd>
<dd>
acc_offset </dd></dl>

</div>
</div>
<a id="a2f0f68ad9a4803efbb1f05c96551872b" name="a2f0f68ad9a4803efbb1f05c96551872b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0f68ad9a4803efbb1f05c96551872b">&#9670;&#160;</a></span>ProcessedData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_processed_data.html">ProcessedData</a> <a class="el" href="struct_processed_data.html">ProcessedData</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure representing processed data including bubble level and shake detection. The <a class="el" href="struct_processed_data.html" title="Structure representing processed data including bubble level and shake detection. The ProcessedData s...">ProcessedData</a> structure is used to store the processed data, which includes the bubble level readings and shake detection result. The roll and pitch variables are of type int16_t and represent the angles of the bubble level along the horizontal (roll) and vertical (pitch) axes. These values indicate the orientation or tilt of the object being measured. The shake variable is of type uint8_t and represents the shake detection result. It is used to indicate whether a shake or vibration event has been detected. A value of 1 indicates a shake or vibration is detected, while a value of 0 indicates no shake or vibration is detected. </p>
<dl class="section see"><dt>See also</dt><dd>roll </dd>
<dd>
pitch </dd>
<dd>
shake </dd></dl>

</div>
</div>
<a id="a1c1a027426b35b6c5326bff15581e0b6" name="a1c1a027426b35b6c5326bff15581e0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1a027426b35b6c5326bff15581e0b6">&#9670;&#160;</a></span>RawData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_raw_data.html">RawData</a> <a class="el" href="struct_raw_data.html">RawData</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af7d279570f140f310e675e91b1d73b1a" name="af7d279570f140f310e675e91b1d73b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d279570f140f310e675e91b1d73b1a">&#9670;&#160;</a></span>mpu9dof_calibrate_module()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpu9dof_calibrate_module </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calibrates the 9DOF MPU module by calculating the value of the sample data. This function performs calibration for the 9DOF MPU module. The calibration process is performed by reading gyro data using the <a class="el" href="mpu9dof_8c.html#abc02bdc34e18dabb24af73d49310a0df" title="Read sensor data from MPU9DOF module.">mpu9dof_read()</a> function with the sensor type set to GYRO. The sample data is accumulated in the gyro_sum array. After collecting the required number of samples defined by CALIBRATION_SAMPLES, the mean value is calculated for each gyro axis. The gyro offset values are stored in the offsetValues.gyro_offset array, and the calibrated gyro data is stored in the calibratedData.gyro_calib array. Additionally, a normal 1G offset of the accelerometer in the Z-axis is accounted for by subtracting 16384 from the offsetValues.acc_offset[2] value. The calibrated accelerometer data is stored in the calibratedData.acc_calib[2] variable. </p>
<dl class="section note"><dt>Note</dt><dd>The calibration process assumes that the sensor is at a stable and neutral position during calibration. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="mpu9dof_8c.html#abc02bdc34e18dabb24af73d49310a0df" title="Read sensor data from MPU9DOF module.">mpu9dof_read()</a> </dd>
<dd>
<a class="el" href="mpu9dof_8c.html#a1159e4f53de21839e7731629ab36c2d6" title="Specifies the number of example values to be recorded for calibration. This constant variable determi...">CALIBRATION_SAMPLES</a> </dd>
<dd>
<a class="el" href="nucleo-l432kc__9dof-imu-click_2_core_2_src_2freertos_8c.html#ac2203bf8f6dd5851eca6112dea4f7b1b">GYRO</a> </dd>
<dd>
gyro_sum </dd>
<dd>
offsetValues.gyro_offset </dd>
<dd>
calibratedData.gyro_calib </dd>
<dd>
offsetValues.acc_offset </dd>
<dd>
calibratedData.acc_calib </dd></dl>
<p >Apply a normal 1G offset correction to the Z-axis accelerometer data.</p>

</div>
</div>
<a id="a949f4308c28a7a773584c8e6c281e3cb" name="a949f4308c28a7a773584c8e6c281e3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949f4308c28a7a773584c8e6c281e3cb">&#9670;&#160;</a></span>mpu9dof_default_cfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpu9dof_default_cfg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: </dd></dl>
<p >Chip reset: Resets the chip and adds a 10ms delay.</p>
<p >Initialize accel &amp; gyro: Sets the sample rate divider to default value and adds a 10ms delay.</p>
<p >Disable FIFOs: Disables the FIFO feature and adds a 10ms delay.</p>
<p >Bypass mode enabled: Enables the bypass mode by setting the appropriate configuration in the INT_PIN_CFG register. Adds a 10ms delay.</p>
<p >Disable all interrupts: Disables all interrupts by writing the default value to the INT_ENABLE register. Adds a 10ms delay.</p>
<p >No FIFO and no I2C slaves: Disables the FIFO and I2C slave features by setting the default value in the USER_CTRL register. Adds a 10ms delay.</p>
<p >No power management, internal clock source: Disables power management and sets the internal clock source by writing the default value to the PWR_MGMT_1 register. Adds a 10ms delay.</p>

</div>
</div>
<a id="a01269a22d6a6e761803b82be318f568e" name="a01269a22d6a6e761803b82be318f568e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01269a22d6a6e761803b82be318f568e">&#9670;&#160;</a></span>mpu9dof_generic_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpu9dof_generic_read </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic read function for MPU9DOF module. This function is used to read data from the MPU9DOF module. It accepts a register address specified by the reg parameter, a data buffer specified by the data_buf parameter, and the length of the data buffer specified by the len parameter. The function begins by acquiring a critical section to ensure exclusive access to shared resources. It then calls the HAL_I2C_Mem_Read function to read data from the MPU9DOF module. The function specifies the I2C interface (hi2c1), the I2C device address obtained by left-shifting MPU9DOF_XLG_I2C_ADDR_1 by 1, the register address (*reg), the size of the register address (I2C_MEMADD_SIZE_8BIT), the data buffer to store the read data (data_buf), the length of the data to be read (*len), and the maximum delay for the operation (HAL_MAX_DELAY). Finally, the function releases the critical section and returns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>Pointer to the register address. </td></tr>
    <tr><td class="paramname">data_buf</td><td>Pointer to the data buffer to store the read data. </td></tr>
    <tr><td class="paramname">len</td><td>Pointer to the length of the data buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___exported___functions___group2.html#ga7b593a1b85bd989dd002ee209eae4ad2">HAL_I2C_Mem_Read</a> </dd>
<dd>
<a class="el" href="mpu9dof_8c.html#ace92afad010308cb88a74c110408833a">MPU9DOF_XLG_I2C_ADDR_1</a> </dd></dl>

</div>
</div>
<a id="a19362190b7708f09cf198ac33319d513" name="a19362190b7708f09cf198ac33319d513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19362190b7708f09cf198ac33319d513">&#9670;&#160;</a></span>mpu9dof_generic_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpu9dof_generic_write </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic write function for MPU9DOF module. </p>
<p >This function is used to write data to the MPU9DOF module. It accepts a register address specified by the reg parameter, a data buffer specified by the data_buf parameter and the length of the data buffer specified by the len parameter. The function begins by acquiring a critical section to ensure exclusive access to shared resources. It then constructs a data array with the register address as the first element and copies the data from the data buffer into the remaining elements using the memcpy function. The function then calls the HAL_I2C_Master_Transmit function to transmit the data array over the I2C interface to the MPU9DOF module. The I2C address used for transmission is obtained by left-shifting the constant MPU9DOF_XLG_I2C_ADDR_1 by 1.</p>
<p >Finally, the function releases the critical section and returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>Pointer to the register address. </td></tr>
    <tr><td class="paramname">data_buf</td><td>Pointer to the data buffer. </td></tr>
    <tr><td class="paramname">len</td><td>Pointer to the length of the data buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___i2_c___exported___functions___group2.html#ga9440a306e25c7bd038cfa8619ec9a830">HAL_I2C_Master_Transmit</a> </dd>
<dd>
memcpy </dd>
<dd>
<a class="el" href="mpu9dof_8c.html#ace92afad010308cb88a74c110408833a">MPU9DOF_XLG_I2C_ADDR_1</a> </dd></dl>

</div>
</div>
<a id="a5433079579490b97f6094c3659af0089" name="a5433079579490b97f6094c3659af0089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5433079579490b97f6094c3659af0089">&#9670;&#160;</a></span>mpu9dof_log_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpu9dof_log_data </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Log data based on the specified type. </p>
<p >This function logs different types of data based on the value of *data. The function accepts a pointer to the data variable, which is used in a switch statement to determine the type of data to log. If *data is 1, the function logs the raw accelerometer and gyroscope data by printing the values of rawData.acc and rawData.gyro using the printf function. If *data is 2, the function logs the calibration offset for the gyroscope by printing the values of offsetValues.gyro_offset using the printf function. If *data is 3, the function logs the calibrated data. (TODO: Add details if available.) If *data is 4, the function logs the processed final data, including the roll, pitch, and shake values from processedData, using the printf function.</p>
<p >If none of the above cases match, indicating an invalid value for *data, an error message is printed using the printf function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the data type specifier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>rawData.acc </dd>
<dd>
rawData.gyro </dd>
<dd>
offsetValues.gyro_offset </dd>
<dd>
processedData.roll </dd>
<dd>
processedData.pitch </dd>
<dd>
processedData.shake </dd></dl>

</div>
</div>
<a id="a62e71fb6014f5c2527ce9ba6928cec83" name="a62e71fb6014f5c2527ce9ba6928cec83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e71fb6014f5c2527ce9ba6928cec83">&#9670;&#160;</a></span>mpu9dof_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * mpu9dof_process </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process sensor data and calculate roll, pitch, and shake detection. This function processes the sensor data and performs calculations to determine the roll, pitch, and shake detection values. It takes the raw gyro and accelerometer data from rawData and applies necessary conversions to obtain the values in appropriate units. The function converts the raw gyro values to degrees per second by subtracting the gyro offset values and dividing by 131.0. Similarly, the raw accelerometer values are converted to G's by dividing them by 4096.0. The roll and pitch angles are calculated from the accelerometer data using the atan2f function and then converted to degrees by multiplying with the RAD_TO_DEG constant. The complementary filter is applied to combine the gyro and accelerometer data for the roll and pitch angles. The filtered roll and pitch values are updated in processedData using the COMPLEMENTARY_RATIO and DELTA_TIME constants. The shake detection is performed by calculating the magnitude of the accelerometer readings and comparing it to the SHAKE_THRESHOLD. If the magnitude exceeds the threshold, shake is considered to be detected, and the processedData.shake value is set to 0; otherwise, it is set to 1. The function returns a pointer to the processedData structure containing the calculated roll, pitch, and shake values. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the processedData structure. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>rawData.gyro </dd>
<dd>
offsetValues.gyro_offset </dd>
<dd>
rawData.acc </dd>
<dd>
<a class="el" href="mpu9dof_8c.html#aa13aa37077c3b71dfcadf38e1bc7bfe4">COMPLEMENTARY_RATIO</a> </dd>
<dd>
<a class="el" href="mpu9dof_8c.html#ad41d7e66c90529c1f3d8e8be9df8ed95">DELTA_TIME</a> </dd>
<dd>
processedData.roll </dd>
<dd>
processedData.pitch </dd>
<dd>
<a class="el" href="mpu9dof_8c.html#a3e92e8253a6240e36fc8ed496aec2a03" title="Constants for motion sensing. These constants define various parameters used in motion sensing calcul...">SHAKE_THRESHOLD</a> </dd>
<dd>
processedData.shake </dd>
<dd>
<a class="el" href="mpu9dof_8c.html#a374e8373687339ac309e4f02b305fb0f">RAD_TO_DEG</a> </dd></dl>

</div>
</div>
<a id="abc02bdc34e18dabb24af73d49310a0df" name="abc02bdc34e18dabb24af73d49310a0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc02bdc34e18dabb24af73d49310a0df">&#9670;&#160;</a></span>mpu9dof_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpu9dof_read </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>sensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read sensor data from MPU9DOF module. </p>
<p >This function reads sensor data from the MPU9DOF module based on the provided sensor type. The sensor type is specified using the parameter sensor. If sensor is equal to 1, the function reads gyro data from the module's registers, including X, Y, and Z-axis gyro values, and stores them in the rawData.gyro array. If sensor is equal to 2, the function reads accelerometer data from the module's registers, including X, Y, and Z-axis accelerometer values, and stores them in the rawData.acc array. If sensor is neither 1 nor 2, an error message is printed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sensor</td><td>Sensor type to read data from. Valid values are 1 (gyro) and 2 (accelerometer).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="mpu9dof_8c.html#a01269a22d6a6e761803b82be318f568e" title="Generic read function for MPU9DOF module. This function is used to read data from the MPU9DOF module....">mpu9dof_generic_read()</a> </dd>
<dd>
<a class="el" href="mpu9dof_8c.html#aa003a2decca0e11c619289f80f9d33ff" title="High registers of the gyroscope and accelerometer. These constants define the addresses of the high r...">MPU9DOF_GYRO_XOUT_H</a> </dd>
<dd>
<a class="el" href="mpu9dof_8c.html#aa0f9f5d494a3ccc3c87c8fb88ae287dd">MPU9DOF_GYRO_YOUT_H</a> </dd>
<dd>
<a class="el" href="mpu9dof_8c.html#a05da3d1b8555e6647aa4bcb108cd47f1">MPU9DOF_GYRO_ZOUT_H</a> </dd>
<dd>
<a class="el" href="mpu9dof_8c.html#a5ee7c56be6f5ccd8c9fc46bd8f64fe1d">MPU9DOF_ACCEL_XOUT_H</a> </dd>
<dd>
<a class="el" href="mpu9dof_8c.html#af3ab19293e1923b48e195a2cba1bdb0e">MPU9DOF_ACCEL_YOUT_H</a> </dd>
<dd>
<a class="el" href="mpu9dof_8c.html#a323047f22c2674ae3ea96f2c4f8d331d">MPU9DOF_ACCEL_ZOUT_H</a> </dd>
<dd>
rawData.gyro </dd>
<dd>
rawData.acc </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7930346cc386f4dd9d626edcc6bdc716" name="a7930346cc386f4dd9d626edcc6bdc716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7930346cc386f4dd9d626edcc6bdc716">&#9670;&#160;</a></span>calibratedData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_calibrated_data.html">CalibratedData</a> calibratedData</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1159e4f53de21839e7731629ab36c2d6" name="a1159e4f53de21839e7731629ab36c2d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1159e4f53de21839e7731629ab36c2d6">&#9670;&#160;</a></span>CALIBRATION_SAMPLES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t CALIBRATION_SAMPLES = 50</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the number of example values to be recorded for calibration. This constant variable determines the number of example values that should be recorded for the calibration process. It is of type uint8_t, which represents an unsigned 8-bit integer. The calibration process is used to establish reference values or parameters for calculations. </p>
<dl class="section note"><dt>Note</dt><dd>Adjusting this value may impact the accuracy and reliability of the calibration process. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="mpu9dof_8c.html#a1159e4f53de21839e7731629ab36c2d6" title="Specifies the number of example values to be recorded for calibration. This constant variable determi...">CALIBRATION_SAMPLES</a> </dd></dl>

</div>
</div>
<a id="aa13aa37077c3b71dfcadf38e1bc7bfe4" name="aa13aa37077c3b71dfcadf38e1bc7bfe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13aa37077c3b71dfcadf38e1bc7bfe4">&#9670;&#160;</a></span>COMPLEMENTARY_RATIO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float COMPLEMENTARY_RATIO = 0.98</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad41d7e66c90529c1f3d8e8be9df8ed95" name="ad41d7e66c90529c1f3d8e8be9df8ed95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41d7e66c90529c1f3d8e8be9df8ed95">&#9670;&#160;</a></span>DELTA_TIME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float DELTA_TIME = 1.0/30.0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7b2c26e44dadaaa798a5c3d82914ba7" name="af7b2c26e44dadaaa798a5c3d82914ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b2c26e44dadaaa798a5c3d82914ba7">&#9670;&#160;</a></span>hi2c1</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___i2_c__handle___structure__definition.html#ga31b88eb31a4622a50e34f02a1c3d516b">I2C_HandleTypeDef</a> hi2c1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b219909a48ba3d698653a9848002115" name="a7b219909a48ba3d698653a9848002115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b219909a48ba3d698653a9848002115">&#9670;&#160;</a></span>MPU9DOF_ACCEL_CONFIG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_ACCEL_CONFIG = 0x1C</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ee7c56be6f5ccd8c9fc46bd8f64fe1d" name="a5ee7c56be6f5ccd8c9fc46bd8f64fe1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee7c56be6f5ccd8c9fc46bd8f64fe1d">&#9670;&#160;</a></span>MPU9DOF_ACCEL_XOUT_H</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_ACCEL_XOUT_H = 0x3B</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3ab19293e1923b48e195a2cba1bdb0e" name="af3ab19293e1923b48e195a2cba1bdb0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ab19293e1923b48e195a2cba1bdb0e">&#9670;&#160;</a></span>MPU9DOF_ACCEL_YOUT_H</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_ACCEL_YOUT_H = 0x3D</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a323047f22c2674ae3ea96f2c4f8d331d" name="a323047f22c2674ae3ea96f2c4f8d331d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323047f22c2674ae3ea96f2c4f8d331d">&#9670;&#160;</a></span>MPU9DOF_ACCEL_ZOUT_H</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_ACCEL_ZOUT_H = 0x3F</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bc769bbe277a45f1c29e1e7a18ccb2d" name="a4bc769bbe277a45f1c29e1e7a18ccb2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc769bbe277a45f1c29e1e7a18ccb2d">&#9670;&#160;</a></span>MPU9DOF_BIT_FIFO_DIS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_BIT_FIFO_DIS = 0x00</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b750fec54c6406d16a2c0238dcf56af" name="a4b750fec54c6406d16a2c0238dcf56af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b750fec54c6406d16a2c0238dcf56af">&#9670;&#160;</a></span>MPU9DOF_BIT_H_RESET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_BIT_H_RESET = 0x80</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5912f4f5b0d9e8556f28b98925153ac1" name="a5912f4f5b0d9e8556f28b98925153ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5912f4f5b0d9e8556f28b98925153ac1">&#9670;&#160;</a></span>MPU9DOF_BIT_INT_PIN_CFG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_BIT_INT_PIN_CFG = 0x02</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f45263b150c5a7926b58ae1fefd3806" name="a9f45263b150c5a7926b58ae1fefd3806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f45263b150c5a7926b58ae1fefd3806">&#9670;&#160;</a></span>MPU9DOF_BITS_AFSL_SEL_8G</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_BITS_AFSL_SEL_8G = 0x10</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3aade376745f1e7a469a10b26ebd551b" name="a3aade376745f1e7a469a10b26ebd551b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aade376745f1e7a469a10b26ebd551b">&#9670;&#160;</a></span>MPU9DOF_BITS_DLPF_CFG_42HZ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_BITS_DLPF_CFG_42HZ = 0x03</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd230107adbbce5cf82791ef10e9dd23" name="abd230107adbbce5cf82791ef10e9dd23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd230107adbbce5cf82791ef10e9dd23">&#9670;&#160;</a></span>MPU9DOF_BITS_FS_250DPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_BITS_FS_250DPS = 0x00</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sensitivity settings for accelerometer and gyroscope. These constants define the sensitivity settings for the accelerometer and gyroscope of the MPU-9DOF sensor. MPU9DOF_BITS_FS_250DPS: Sensitivity setting for the gyroscope at 250 degrees per second. MPU9DOF_BITS_AFSL_SEL_8G: Sensitivity setting for the accelerometer at 8g. </p>

</div>
</div>
<a id="ad6b2f8caba4e8478afe874b05b753580" name="ad6b2f8caba4e8478afe874b05b753580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b2f8caba4e8478afe874b05b753580">&#9670;&#160;</a></span>MPU9DOF_CONFIG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_CONFIG = 0x1A</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49e0846dacaf6675bc6466a4d70ca723" name="a49e0846dacaf6675bc6466a4d70ca723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e0846dacaf6675bc6466a4d70ca723">&#9670;&#160;</a></span>MPU9DOF_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_DEFAULT = 0x00</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0c83376e098321319e0c103239aeae3" name="ab0c83376e098321319e0c103239aeae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c83376e098321319e0c103239aeae3">&#9670;&#160;</a></span>MPU9DOF_FIFO_EN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_FIFO_EN = 0x23</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa68dd2a28e55296623b64ccf23981bae" name="aa68dd2a28e55296623b64ccf23981bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68dd2a28e55296623b64ccf23981bae">&#9670;&#160;</a></span>MPU9DOF_GYRO_CONFIG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_GYRO_CONFIG = 0x1B</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa003a2decca0e11c619289f80f9d33ff" name="aa003a2decca0e11c619289f80f9d33ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa003a2decca0e11c619289f80f9d33ff">&#9670;&#160;</a></span>MPU9DOF_GYRO_XOUT_H</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_GYRO_XOUT_H = 0x43</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>High registers of the gyroscope and accelerometer. These constants define the addresses of the high registers of the gyroscope and accelerometer in the MPU-9DOF sensor. MPU9DOF_GYRO_XOUT_H: Address of the high register for the X-axis gyroscope output. MPU9DOF_GYRO_YOUT_H: Address of the high register for the Y-axis gyroscope output. MPU9DOF_GYRO_ZOUT_H: Address of the high register for the Z-axis gyroscope output. MPU9DOF_ACCEL_XOUT_H: Address of the high register for the X-axis accelerometer output. MPU9DOF_ACCEL_YOUT_H: Address of the high register for the Y-axis accelerometer output. MPU9DOF_ACCEL_ZOUT_H: Address of the high register for the Z-axis accelerometer output. </p>

</div>
</div>
<a id="aa0f9f5d494a3ccc3c87c8fb88ae287dd" name="aa0f9f5d494a3ccc3c87c8fb88ae287dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f9f5d494a3ccc3c87c8fb88ae287dd">&#9670;&#160;</a></span>MPU9DOF_GYRO_YOUT_H</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_GYRO_YOUT_H = 0x45</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05da3d1b8555e6647aa4bcb108cd47f1" name="a05da3d1b8555e6647aa4bcb108cd47f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05da3d1b8555e6647aa4bcb108cd47f1">&#9670;&#160;</a></span>MPU9DOF_GYRO_ZOUT_H</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_GYRO_ZOUT_H = 0x47</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0196791086d75eab99490549ff150ad6" name="a0196791086d75eab99490549ff150ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0196791086d75eab99490549ff150ad6">&#9670;&#160;</a></span>MPU9DOF_INT_ENABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_INT_ENABLE = 0x38</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18c9eeb5dfe6896666902cb99a13d527" name="a18c9eeb5dfe6896666902cb99a13d527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c9eeb5dfe6896666902cb99a13d527">&#9670;&#160;</a></span>MPU9DOF_INT_PIN_CFG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_INT_PIN_CFG = 0x37</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90aa4fe3af751fa4f17406a9c98f67e2" name="a90aa4fe3af751fa4f17406a9c98f67e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90aa4fe3af751fa4f17406a9c98f67e2">&#9670;&#160;</a></span>MPU9DOF_PWR_MGMT_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_PWR_MGMT_1 = 0x6B</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aedc1c865f06de7a6fab00a6084fb86fe" name="aedc1c865f06de7a6fab00a6084fb86fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc1c865f06de7a6fab00a6084fb86fe">&#9670;&#160;</a></span>MPU9DOF_PWR_MGMT_2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_PWR_MGMT_2 = 0x6C</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa373db1d9e00d5d106cca10baa96ea84" name="aa373db1d9e00d5d106cca10baa96ea84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa373db1d9e00d5d106cca10baa96ea84">&#9670;&#160;</a></span>MPU9DOF_SMPLRT_DIV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_SMPLRT_DIV = 0x19</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbcc92b4f26c722f378422726a6f0d72" name="afbcc92b4f26c722f378422726a6f0d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbcc92b4f26c722f378422726a6f0d72">&#9670;&#160;</a></span>MPU9DOF_USER_CTRL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_USER_CTRL = 0x6A</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace92afad010308cb88a74c110408833a" name="ace92afad010308cb88a74c110408833a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace92afad010308cb88a74c110408833a">&#9670;&#160;</a></span>MPU9DOF_XLG_I2C_ADDR_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t MPU9DOF_XLG_I2C_ADDR_1 = 0x69</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98f219b8466fd2ccc99d8f7546f9e739" name="a98f219b8466fd2ccc99d8f7546f9e739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f219b8466fd2ccc99d8f7546f9e739">&#9670;&#160;</a></span>offsetValues</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_offset_values.html">OffsetValues</a> offsetValues</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10cb247ad8a7279a9d4e6b505496bc4b" name="a10cb247ad8a7279a9d4e6b505496bc4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10cb247ad8a7279a9d4e6b505496bc4b">&#9670;&#160;</a></span>processedData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_processed_data.html">ProcessedData</a> processedData</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a374e8373687339ac309e4f02b305fb0f" name="a374e8373687339ac309e4f02b305fb0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374e8373687339ac309e4f02b305fb0f">&#9670;&#160;</a></span>RAD_TO_DEG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float RAD_TO_DEG = 57.2957795131</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a58ed8cae092f222d56fb8b32a99080" name="a6a58ed8cae092f222d56fb8b32a99080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a58ed8cae092f222d56fb8b32a99080">&#9670;&#160;</a></span>rawData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_raw_data.html">RawData</a> rawData</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e92e8253a6240e36fc8ed496aec2a03" name="a3e92e8253a6240e36fc8ed496aec2a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e92e8253a6240e36fc8ed496aec2a03">&#9670;&#160;</a></span>SHAKE_THRESHOLD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float SHAKE_THRESHOLD = 2.5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constants for motion sensing. These constants define various parameters used in motion sensing calculations. SHAKE_THRESHOLD: Threshold for detecting shaking motion, specified in units of G's (acceleration due to gravity). DELTA_TIME: Time interval between sensor readings, expressed as the reciprocal of the sampling rate (30 times per second). RAD_TO_DEG: Conversion constant for converting radians to degrees. COMPLEMENTARY_RATIO: Complementary filter ratio used in sensor fusion algorithms, obtained from external knowledge sources. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
